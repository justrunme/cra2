#!/bin/bash
set -e  # –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è –ø—Ä–∏ –æ—à–∏–±–∫–µ
set -x  # –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–∞–∂–¥—É—é –∫–æ–º–∞–Ω–¥—É
trap 'echo "‚ùå FAILED at line $LINENO with exit code $?"' ERR

echo "üîé Debugging update-all..."

# === Determine SCRIPT_DIR
if [[ -f "/opt/cra2/modules/colors.sh" ]]; then
  SCRIPT_DIR="/opt/cra2"
else
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi
MODULES_DIR="$SCRIPT_DIR/modules"

# === Load modules
source "$MODULES_DIR/colors.sh"
source "$MODULES_DIR/logger.sh"
source "$MODULES_DIR/config.sh"
source "$MODULES_DIR/platform.sh"
source "$MODULES_DIR/git.sh"
source "$MODULES_DIR/utils.sh"
source "$MODULES_DIR/repo.sh"

PULL_ONLY=false
DRY_RUN=false
ONLY_TAGS=""

echo "‚ñ∂Ô∏è Parsing flags: $*"
for arg in "$@"; do
  case "$arg" in
    --pull-only)
      PULL_ONLY=true
      ;;
    --dry-run)
      DRY_RUN=true
      ;;
    --only-tags=*)
      ONLY_TAGS="${arg#*=}"
      ;;
    --help)
      echo "Usage: update-all [--pull-only] [--dry-run] [--only-tags=TAG]"
      exit 0
      ;;
    *)
      echo -e "${RED}‚ùå Unknown flag: $arg${RESET}"
      suggest_flag "$arg"
      exit 1
      ;;
  esac
done

LIST_FILE="$HOME/.repo-autosync.list"
LOG_FILE="$HOME/.create-repo.log"
ERROR_LOG="$HOME/.create-repo-errors.log"

# 1) Lock if enable_lock=true
echo "‚ÑπÔ∏è Loading config..."
load_config

if [[ "$enable_lock" == "true" ]]; then
  echo "üîí Attempting to lock /tmp/update-all.lock"
  LOCKFILE="/tmp/update-all.lock"
  exec 200>"$LOCKFILE"
  if ! flock -n 200; then
    echo -e "${YELLOW}‚ö†Ô∏è Another update-all is running. Exiting.${RESET}"
    exit 0
  fi
fi

if [ ! -f "$LIST_FILE" ]; then
  echo -e "${YELLOW}‚ö†Ô∏è No repos tracked. Use create-repo to track repositories.${RESET}"
  exit 0
fi

echo -e "${BOLD}üîÑ Starting sync of tracked repositories...${RESET}"

FAIL_COUNT=0  # —Å—á—ë—Ç—á–∏–∫, –µ—Å–ª–∏ —Ö–æ—Ç–∏–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å, —á—Ç–æ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ä–µ–ø–æ —É–ø–∞–ª

while IFS= read -r repo_path || [[ -n "$repo_path" ]]; do
  [ -z "$repo_path" ] && continue

  if [ ! -d "$repo_path/.git" ]; then
    echo -e "${RED}‚ùå Not a Git repo: $repo_path${RESET}"
    continue
  fi

  cd "$repo_path"
  PROJECT_NAME=$(basename "$repo_path")

  echo -e "\nüìÅ ${BOLD}$PROJECT_NAME${RESET} (${DIM}$repo_path${RESET})"

  # –õ–æ–∫–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ñ–∏–≥
  LOCAL_CONF="$repo_path/.create-repo.local.conf"
  if [ -f "$LOCAL_CONF" ]; then
    echo "‚ÑπÔ∏è source local config: $LOCAL_CONF"
    source "$LOCAL_CONF"
    if [[ "$disable_sync" == "true" ]]; then
      echo -e "üö´ ${YELLOW}$PROJECT_NAME skipped (disabled via local config)${RESET}"
      continue
    fi
  fi

  # selective sync
  if [ -n "$ONLY_TAGS" ]; then
    if [[ -z "$sync_tags" ]]; then
      echo "üö´ $PROJECT_NAME has no sync_tags, skipping"
      continue
    fi
    intersect=$(echo "$sync_tags" | grep -o "$ONLY_TAGS" || true)
    if [ -z "$intersect" ]; then
      echo "üö´ $PROJECT_NAME (tags: $sync_tags) doesn't match --only-tags=$ONLY_TAGS, skipping"
      continue
    fi
  fi

  if [ "$PULL_ONLY" = true ]; then
    echo "üåÄ Pull-only mode ‚Üí skipping push"
    export PULL_ONLY=true
  fi
  if [ "$DRY_RUN" = true ]; then
    echo "üß™ Dry-run mode, set NO_PUSH=true"
    export NO_PUSH=true
  fi

  echo "üöÄ Calling sync_now..."
  if sync_now; then
    echo "‚úÖ sync_now returned success (code $?)"
    log_success "$PROJECT_NAME" "$repo_path"
  else
    # sync_now –≤–µ—Ä–Ω—É–ª –∫–æ–¥ ‚â† 0
    echo "‚ùå Sync failed for $PROJECT_NAME (code $?)."
    log_error "$PROJECT_NAME" "$repo_path"
    FAIL_COUNT=$((FAIL_COUNT+1))
    # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –ø–æ–ª–Ω–æ—Å—Ç—å—é, –∏–¥—ë–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Ä–µ–ø–æ
  fi
done < "$LIST_FILE"

echo "‚ÑπÔ∏è Done looping over repos. FAIL_COUNT=$FAIL_COUNT"

if [ "$FAIL_COUNT" -gt 0 ]; then
  echo "‚ö†Ô∏è Some repos failed to sync."
  # –ï—Å–ª–∏ —Ö–æ—Ç–∏–º, –≤—ã—Ö–æ–¥–∏–º –∫–æ–¥–æ–º 1
  exit 1
fi

echo "‚úÖ All repos synced (or no changes). Exiting 0."
exit 0
